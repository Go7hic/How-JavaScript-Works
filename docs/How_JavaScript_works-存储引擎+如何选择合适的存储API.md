# JavaScript 是如何工作的: 存储引擎+如何选择合适的存储API

这是专门探索JavaScript及其构建组件的系列文章的第16篇。 在识别和描述核心元素的过程中，我们还分享了一些我们在构建SessionStack时使用的经验法则，这是一个JavaScript应用程序，需要强大且高性能，以帮助用户实时查看和重现其Web应用程序缺陷。

#### 概述
在设计Web应用程序时，为本地设备存储选择正确的存储机制至关重要。 良好的存储引擎可确保您的信息可靠保存，减少带宽并提高响应能力。 正确的存储缓存策略是实现离线移动Web体验的核心构建块，默认情况下，越来越多的用户认为应该是这种情况。

在本章中，我们将讨论可用的存储API和服务，并将提供有关如何在构建Web应用程序时做出正确选择的一些指导。

#### 数据模型
数据存储模型确定数据在内部的组织方式。 这会影响您的Web应用程序的整个设计，定义权衡以使您的Web应用程序高效，同时解决它应该解决的问题。 没有“更好”的方法，也没有任何一刀切的解决方案，几乎所有与工程相关的方法都是如此。 那么，让我们来看看您可以选择的数据模型：
- Structured结构：存储在具有预定义字段的表中的数据，这是基于SQL的数据库管理系统的典型特征，非常适合灵活和动态的查询。 IndexedDB是浏览器中结构化数据存储的一个突出示例。
- Key/Value键/值：键/值数据存储区和相关的NoSQL数据库提供存储和检索由唯一键索引的非结构化数据的功能。 键/值数据存储区就像哈希表，它们允许对索引的不透明数据进行恒定时间访问。 键/值数据存储的良好示例是浏览器中的Cache API和服务器上的Apache Cassandra。
- Byte Streams字节流：这个简单的模型将数据存储为长度变量，不透明的字节串，将任何形式的内部组织留给应用层。 此模型特别适用于文件系统和其他分层组织的数据blob。 字节流数据存储的突出示例包括文件系统和云存储服务。
#### Persistence (持久性)
可以根据数据持久性的时间范围分析Web应用程序的存储方法：
- Session Persistence 会话持久性：只有单个Web会话或浏览器选项卡保持活动状态时，此类别中的数据才会保留。 具有会话持久性的存储机制的示例是会话存储API。
- Device Persistence 设备持久性：此类别中的数据在特定设备上的会话和浏览器选项卡/窗口之间保持不变。 具有设备持久性的存储机制的示例是Cache API。
- Global Persistence 全局持久性：此类别中的数据在会话和设备之间保持不变。 因此，它是最强大的数据持久性形式。 但是，它无法存储在设备本身上，这意味着您需要某种服务器端存储。 我们不会在这里详细讨论，因为这篇文章的重点是在设备本身上存储数据。

#### 浏览器中的数据持久性

如今，有很多浏览器API允许您存储数据。 我们将介绍其中一些并创建比较，以便您更轻松地选择正确的选项。

但是，首先，在选择如何保留数据之前，您应该考虑一些事项。 当然，您必须首先了解的是您的Web应用程序的使用方式以及以后的维护和增强。 即使您有这些问题的答案，您最终也可以选择一些选项。 所以，这是你应该看到的：

- Browser Support 浏览器支持 - 您应该考虑到标准化和完善的API更可取的事实，因为它们往往寿命更长，支持更广泛。这些API还享有更广泛的文档和更丰富的开发人员社区。
- Transactions 事务 - 有时，相关存储操作的集合以原子方式成功或失败是很重要的。传统上，数据库使用事务模型支持此功能，其中相关更新可以分组为任意单元。
- Sync/Async 同步/异步 - 某些存储API是同步的，因为存储或检索请求会阻止当前活动的线程，直到请求完成。使用同步存储API可以阻止主线程并为Web应用程序的UI创建冻结体验。如果可能，请使用异步API。

#### 对比（Comparison）
在本节中，我们将了解Web开发人员可用的当前API，并在上述维度中进行比较。
![](https://ws3.sinaimg.cn/large/0069RVTdgy1fu2bggt1i7j31kw0be0vl.jpg)

#### File system API
![](https://cdn-images-1.medium.com/max/1600/0*9KPehy4mUb8f-hSp)

使用FileSystem API，Web应用程序可以创建，读取，导航和写入用户本地文件系统的沙盒部分。

API分为各种主题：

- 读取和操作文件：File / Blob，FileList，FileReader
- 创建和编写：Blob（），FileWriter
- 目录和文件系统访问：DirectoryReader，FileEntry / DirectoryEntry，LocalFileSystem
文件系统API是非标准API。您不应该在生产Web应用程序中使用它，因为它不适用于每个用户。实现之间可能存在很大的不兼容性，并且将来可能会改变行为。

文件和目录条目API接口FileSystem用于表示文件系统。可以从任何文件系统条目上的filesystem属性获取这些对象。某些浏览器提供了额外的API来创建和管理文件系统。

此接口不会授予您访问用户文件系统的权限。相反，您将在浏览器沙箱中拥有一个“虚拟驱动器”。如果要访问用户的文件系统，则需要通过例如调用用户。安装Chrome扩展程序。

#### 请求文件系统
Web应用程序可以通过调用`window.requestFileSystem（）`来请求访问沙盒文件系统：
```js
// Note: The file system has been prefixed as of Google Chrome 12:
window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
window.requestFileSystem(type, size, successCallback, opt_errorCallback)
```

如果您是第一次调用requestFileSystem（），则会为您的应用创建新存储。 重要的是要记住这个文件系统是沙盒，这意味着一个Web应用程序无法访问另一个应用程序的文件。

在访问文件系统后，您可以对文件和目录执行大多数标准操作。

与其他文件系统相比，FileSystem是一个完全不同的存储选项，因为它旨在满足数据库不能很好地服务的客户端存储用例。 通常，这些应用程序处理大型二进制blob和/或与浏览器上下文之外的应用程序共享数据。

这些是FileSystem API的良好用例：
- Persistent uploader持久上传器 - 当选择上传文件或目录时，它会将文件复制到本地沙箱并一次上传一个块。
- 视频游戏，音乐或其他具有大量媒体资产的应用
- 具有离线访问的音频/照片编辑器或用于速度的本地缓存 - 数据blob可能非常大并且是可读写的。
- Offline video viewer离线视频查看器 - 它需要下载大文件以供以后查看或高效搜索+流媒体
- Offline Web Mail Client 脱机Web邮件客户端 - 下载附件并在本地存储它们。

这是API当前的浏览器支持：
![](https://cdn-images-1.medium.com/max/1600/0*ndU4N8xQF6QEQmSY)


#### Local storage
`localStorage` API允许您访问Document的源的Storage对象。 存储的数据将保存在浏览器会话中。 localStorage类似于sessionStorage，但是当localStorage中存储的数据没有到期时间时，存储在sessionStorage中的数据会在页面会话结束时清除 - 也就是说，当页面关闭时。

请注意，存储在localStorage或sessionStorage中的数据特定于页面的来源，它是协议，主机和端口的组合。

这是API当前的浏览器支持：
![](https://cdn-images-1.medium.com/max/1600/0*AsoHzlowoLItnUEL)

#### Session storage

sessionStorage属性允许您访问当前源的会话存储对象。 sessionStorage类似于localStorage，上面简要解释过。 唯一的区别是，虽然存储在localStorage中的数据没有到期设置，但是当页面会话结束时，存储在sessionStorage中的数据会被清除。 只要浏览器处于打开状态，页面会话就会持续，并且会在页面重新加载和恢复后继续存在。 在新选项卡或窗口中打开页面将导致启动新会话，这与会话cookie的工作方式不同。

请注意，存储在sessionStorage或localStorage中的数据特定于页面的来源。

这是API当前的浏览器支持：
![](https://cdn-images-1.medium.com/max/1600/0*hxC_NUPNycUBhj-L)

#### Cookies
![](https://cdn-images-1.medium.com/max/1600/0*PTDs1BkbMgekizit)
Cookie（Web Cookie，浏览器Cookie）是用户服务器发送到用户Web浏览器的一小段数据。 浏览器可以存储它并将其与下一个请求一起发送回同一服务器。 通常，它用于判断两个请求是否来自同一个浏览器 - 例如，保持用户登录。 它记住无状态HTTP协议的有状态信息。

Cookie有三个主要用例：

- 会话管理 - 登录，购物车，游戏分数或服务器应记住的任何其他内容
- 个性化 - 用户首选项，主题和其他设置
- 跟踪 - 记录和分析用户行为


Cookie曾经用于一般客户端存储。 虽然这是在客户端上存储数据的唯一方法，但这是合法的，现在建议选择现代存储API。 Cookie随每个请求一起发送，因此会降低性能（特别是在移动数据连接时）。

有两种类型的cookie：
- 会话cookie - 在客户端关闭时删除它们。 Web浏览器可以使用会话还原，这使得大多数会话cookie成为永久性的，就像浏览器从未关闭一样。
- 永久性cookie - 永久性cookie在特定日期（Expires）或特定时间段（Max-Age）之后到期，而不是在客户端关闭时到期。


请注意，永远不应使用HTTP Cookie存储或传输机密或敏感信息，因为整个机制本质上是不安全的。

而且，正如您可能已经猜到的，Cookie在所有浏览器中得到广泛支持。

#### Cache
![](https://cdn-images-1.medium.com/max/1600/0*XZ2U-ztABhWJOSky)
Cache接口为缓存的Request / Response对象对提供存储机制。请注意，Cache接口会暴露给窗口范围以及工作者。您不必将它与服务工作者一起使用，即使它是在服务工作者规范中定义的。

原点可以有多个名为Cache的对象。您负责实现脚本（例如，在ServiceWorker中）处理缓存更新的方式。除非明确请求，否则缓存中的项目不会更新;除非删除，否则它们不会过期。使用CacheStorage.open（）打开一个特定的，名为Cache的对象，然后调用任何Cache方法来维护Cache。

您还负责定期清除缓存条目。每个浏览器都对给定源可以使用的缓存存储量有硬性限制。缓存配额使用估算值可通过StorageEstimate API获得。浏览器尽最大努力管理磁盘空间，但它可能会删除源的缓存存储。浏览器通常会删除原点的所有数据或不删除任何数据。确保按名称安装版本缓存，并仅从可以安全操作的脚本版本中使用缓存。有关更多信息，请参阅删除旧缓存。

#### IndexedDB
![](https://cdn-images-1.medium.com/max/1600/0*HP66Xm7oe9u8Ofk1)
IndexedDB是一种在用户浏览器中持久存储数据的方法。 因为它允许您创建具有丰富查询能力的Web应用程序，而不管网络可用性如何，这些应用程序可以在线和离线工作。 IndexedDB对于存储大量数据的应用程序（例如，借阅库中的DVD目录）和不需要持久Internet连接的应用程序（例如，邮件客户端，待办事项列表和记事本）。

在本文中，我们将更详细地讨论存储数据库，因为其余的存储API非常有名。 此外，随着现在Web应用程序复杂性的增加，IndexedDB越来越受欢迎。

##### IndexedDB内部细节
IndexedDB允许您存储和检索使用“密钥”存储的对象。您对数据库所做的所有更改都发生在事务中。与大多数Web存储解决方案一样，IndexedDB遵循同源策略。因此，虽然您可以访问域中的存储数据，但您无法跨不同域访问数据。

IndexedDB是一种异步API，可以在大多数情况下使用，包括WebWorkers。它过去也包含同步版本，供web工作者使用，但由于Web社区缺乏兴趣，因此已从规范中删除。

IndexedDB曾经有一个名为WebSQL Database的竞争规范，但它被W3C弃用了。虽然IndexedDB和WebSQL都是存储解决方案，但它们不提供相同的功能。 WebSQL Database是一个关系数据库访问系统，而IndexedDB是一个索引表系统。

不要开始使用IndexedDB，依赖于其他类型数据库的假设。相反，您应该仔细阅读文档。以下是您应该考虑的一些基本概念：
IndexedDB数据库存储键值对 - 值可以是复杂的结构化对象，键可以是这些对象的属性。您可以创建使用对象的任何属性进行快速搜索的索引，以及排序枚举。键也可以是二进制对象。
IndexedDB建立在事务数据库模型之上 - 您在IndexedDB中所做的一切总是发生在事务的上下文中。因此，您无法在事务之外执行命令或打开游标。此外，事务自动提交，无法手动提交。
IndexedDB API主要是异步的 - API不会通过返回值来为您提供数据。相反，您必须传递回调函数。您不会将值“存储”到数据库中，也不会通过同步方法从数据库中“检索”值。相反，您“请求”发生数据库操作。操作完成时，事件会通知您，如果操作成功或失败，您将获得的事件类型通知您。它与XMLHttpRequest（或许多其他JavaScript东西）的工作方式没有什么不同。
- IndexedDB使用大量请求 - 请求是接收先前提到的成功或失败事件的对象。它们具有onsuccess和onerror属性，以及readyState，result和errorCode属性，可以告诉您请求的状态。
- IndexedDB是面向对象的 - IndexedDB不是一个关系数据库，其表用于表示行和列的集合。这种根本差异会影响您设计和构建应用程序的方式。
- IndexedDB不使用结构化查询语言（SQL） - 它对生成游标的索引使用查询，您可以使用该游标在结果集中进行迭代。如果您不熟悉NoSQL系统，请阅读有关NoSQL的Wikipedia文章。
- 同源策略适用于IndexedDB - 源是域，应用程序层协议以及执行脚本的文档的URL端口。每个来源都有自己的相关数据库集。每个数据库都有一个名称，用于在原点内标识它。

##### IndexedDB limitations IndexedDB的缺点
IndexedDB旨在涵盖大多数需要客户端存储的情况。 但是，对于以下几种情况，它尚未设计：

国际化排序 - 并非所有语言都以相同的方式对字符串进行排序，因此不支持国际化排序。 虽然数据库无法以特定的国际化顺序存储数据，但您可以自己对从数据库中读取的数据进行排序。
同步 - API不是为了与服务器端数据库同步而设计的。 您必须编写将客户端indexedDB数据库与服务器端数据库同步的代码。
全文搜索 - API在SQL中没有LIKE运算符的等价物。

此外，请注意浏览器可以在以下条件下消灭数据库（ouch）：
- 用户请求清除 - 许多浏览器具有允许用户擦除为给定网站存储的所有数据的设置，包括cookie，书签，存储的密码和IndexedDB数据。
- 浏览器处于隐私浏览模式 - 某些浏览器具有“隐私浏览”（Firefox）或“隐身”（Chrome）模式。 在会话结束时，浏览器会清除数据库。
- 已达到磁盘或配额限制。
- 数据已损坏..


确切的环境和浏览器功能会随着时间而变化，但浏览器供应商的一般理念是尽可能地保留数据。
![](https://cdn-images-1.medium.com/max/1600/0*kGDQYE70_z58D7na)

#### 选择正确的存储API
正如我已经提到的，最好选择尽可能多的浏览器广泛支持的API，并提供异步调用模型，以最大限度地提高UI响应能力。这些标准自然导致以下技术选择：

- 对于脱机存储，请使用Cache API。此API可在任何支持创建脱机应用程序所需的Service Worker技术的浏览器中使用。 Cache API非常适合存储与已知URL相关联的资源。
- 要存储应用程序状态和用户生成的内容，请使用IndexedDB。这使得用户可以在更多浏览器中脱机工作，而不仅仅是那些支持Cache API的浏览器。


我们在SessionStack使用不同的存储API。例如，我们集成到您的Web应用程序中的库使用cookie和会话存储。原因是我们的库正在收集数据，如用户事件，DOM更改，网络数据，异常，调试消息等，并将它们发送到我们的服务器。我们正在从用户会话中收集此类数据，但我们需要一种正确的方法来确定用户会话何时开始以及何时停止。我们认为会话从一开始就是Web应用程序使用的整个时期，包含所有页面查看和导航，直到用户关闭其浏览器或选项卡，并且在几分钟内我们不使用会话组合返回存储和服务器端逻辑。更重要的是，我们允许您识别各个最终用户，以便我们为您提供每个会话的用户数据。我们依靠cookie来实现这一点（就像其他监控/分析工具一样）。

在我们的应用程序中，您可以观看（按需或实时）收集的事件作为重新创建用户如何偶然发现问题的视频，我们主要使用cookie，因为我们的服务具有RESTful性质，基本上只需要身份验证用于验证，授权和验证请求的令牌。
